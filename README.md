# 商品下单

业务流程：订单服务 创建订单 -> 库存服务 扣减库存

调用库存服务锁库存是一个**远程更新操作**，如果扣减库存成功了，但是由于**网络原因**超时，出现异常，导致订单事务回滚，就会出现数据不一致

商品下单业务的难点：
- 这是一个高并发业务场景，接口必须保证低延迟、高吞吐
- 需要远程调用库存预扣减，扣减成功才能返回订单信息。这里存在网络两将军问题，需要其他手段保证订单与库存的一致性
- 大部分业务场景都有超时关单诉求

## 订单与库存服务的一致性

### Seata 分布式事务

引入 Seata 分布式事务框架，将创建订单、锁库存放在一个全局事务中，要么全部成功要么全部失败

需要新建一个服务作为 TM，订单与库存服务作为 RM，Seata 作为 TC，直接将下单接口放在 TM 中，远程调用订单与库存，最后返回订单创建信息

#### 缺点
不适合高并发场景。AT 模式的实现依赖数据库锁机制，本地事务依赖行锁来实现读写隔离，提交订单的业务流程涉及到创建订单，锁库存等等，订单是用户维度的
数据，并发度不高；但库存记录是 sku 级别的，加全局锁很容易让后续的提交订单业务都阻塞

### 库存扣减流水表+库存对账

当发生网络两将军问题时，订单并未创建，而库存扣减成功了。因此可以通过库存扣减流水表，扣减完成后，记录扣减流水，每一次扣减需要外部传入流水号， 通
过这个全局唯一的流水号反查出订单信息，如果订单并不存在，再把这部分 sku 库存回滚掉

而库存回滚发生的时机又可以考虑用 MQ 延迟消息或者定时任务去做

#### 基于 MQ 延迟消息回滚

![](/doc/定时回滚库存流程.png)

##### 缺点

存在不一致的情况：如果在提交订单后，订单服务的 MQ 消费端宕机，没有关闭订单，库存的 MQ 因为判断订单没有被取消，不会回滚库存，此时如果订单服务
MQ 消费者恢复正常，将订单关闭，会发生订单和库存不一致

降低上述情况的发生的概率策略之一，就是让库存队列的消息存活时间更长比订单队列的消息存活时间更长，让订单服务 MQ 消费者先于库存服务 MQ 消费

#### 基于定时任务回滚

定时去扫库存扣减流水表做库存对账，这种策略相比上一种：
- 可靠性更高，不会发生因为 MQ 宕机导致的不一致情况
- 对于做过库存对账的记录，需要做历史表迁移，避免数据量膨胀，每次扫了重复的记录

# 超时关单

超时关单的技术选型无非定时任务扫库和 MQ 延迟消息
- 定时任务的缺点是时间不精确，并且会在某一时刻对 DB 压力过大
- MQ 的缺点是大部分订单会提前取消或者完成支付，导致那部分消息在存活时间之前都是无效消息，不适用于超时时间长的场景

这里我们假定订单 30 分钟超时，并且时间敏感，选用 RocketMQ 延迟消息

## 本地事务与 MQ 的一致性

既然选用 RocketMQ 超时关单，就要考虑本地事务与 MQ 的一致性问题。这里还是有两种策略，消息任务表和 RocketMQ 事务消息

### 消息任务表

把新建订单写 DB + 远程调用库存服务扣减失败抛异常 + 消息任务写 DB 放在本地事务中，发 MQ 放在本地事务外，写法可参考
com.cyk.mall.order.service.impl.OrderServiceImpl#submitOrder

### RocketMQ 事务消息

RocketMQ 事务消息保证的是消息生产和本地事务的最终一致性， 先发送 half 消息，等待本地事务执行状态，进行消息反查